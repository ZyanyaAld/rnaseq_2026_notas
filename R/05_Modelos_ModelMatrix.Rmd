# Modelos estadisticos

## 12.1 Linear regression example

For example, if we have a linear regression

$$Y = \beta_0 + \beta_1 X + \epsilon$$

with

$$\epsilon \sim N(0, \sigma^2)$$

and we want to explain the meaning of the coefficient $\beta_1$ then we can explain it as:

> **Text:**  
> $\beta_1$ is the average change in our outcome $Y$ for a one unit increase in our explanatory variable $X$

The language here is quite precise and it can be hard to understand the implications of every word. This is the typical starting point for many questions: what does this mean?

**Drawings:**  
Linear regression drawing [image source](link-to-image)

We have three data points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ and we draw a line that shows the relationship between our $X$ and $Y$ variables (each on its own axis).

This line that we have drawn (shown in red) has two components that can be summarized by a small triangle (shown in green).

The triangle has one vertex that touches the Y axis, this is the intercept, also known as $\beta_0$. Then it has a side of length 1 on the x-axis, and $\beta_1$ is the length of the vertical side of the triangle that starts at $Y = \beta_0$ and ends at our diagonal line. That is, $\beta_1$ is the height of the green triangle when the length is equal to 1 on the x-axis.

This visual representation can be useful for understanding the words we started off with.

**Math:**

First, notice that our linear model is $E[Y] = \beta_0 + \beta_1 X$, then we provide two values for $X$: little $x$ and little $x$ plus one, and compute the difference between them. That leads to the following equations (shown further below).

It can be very useful here to explain how the math on that first equation translates to the written text we started off with.

$$
\begin{aligned}
E[Y | X = x + 1] - E[Y | X = x] 
&= (\beta_0 + \beta_1(x + 1)) - (\beta_0 + \beta_1 x) \\
&= \beta_0 + \beta_1 x + \beta_1 - \beta_0 - \beta_1 x \\
&= (\beta_0 - \beta_0) + (\beta_1 x - \beta_1 x) + \beta_1 \\
&= \beta_1
\end{aligned}
$$


## 5.0

Con R, usamos mucho la función model.matrix() y la sintáxis de fórmula Y ~ X1 + X2 tal como en el siguiente ejemplo.

```{r normalize}
## ?model.matrix
mat <- with(trees, model.matrix(log(Volume) ~ log(Height) + log(Girth)))
mat
colnames(mat)
```

¿Cómo interpretamos los nombres de las columnas de mat?


```{r normalize}
summary(lm(log(Volume) ~ log(Height) + log(Girth), data = trees))
```

## 5.1 ExploreModelMatrix

Es un paquete de Bioconductor que nos ayuda a entender los modelos estadísticos que estamos usando gracias a visualizaciones http://www.bioconductor.org/packages/ExploreModelMatrix/ que está descrito en el siguiente artículo.
Revisaremos los ejemplos en http://www.bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html


```{r normalize}
## Datos de ejemplo
(sampleData <- data.frame(
    genotype = rep(c("A", "B"), each = 4),
    treatment = rep(c("ctrl", "trt"), 4)
))
```


```{r normalize}
## Generemos las imágenes usando ExploreModelMatrix
vd <- ExploreModelMatrix::VisualizeDesign(
    sampleData = sampleData,
    designFormula = ~ genotype + treatment,
    textSizeFitted = 4
)

## Veamos las imágenes
cowplot::plot_grid(plotlist = vd$plotlist)
```

**Para verlo desde una forma interactiva**


```{r normalize}
## Usaremos shiny otra vez
app <- ExploreModelMatrix(
    sampleData = sampleData,
    designFormula = ~ genotype + treatment
)
if (interactive()) shiny::runApp(app)
```


## 5.2 Datos de SRP045638

Vamos a usar datos de https://www.ncbi.nlm.nih.gov/sra/?term=SRP045638 procesados con recount3. Primero hay que descargar los datos con los comandos que vimos ayer.


```{r normalize}
library("recount3")

human_projects <- available_projects()
```


```{r normalize}
rse_gene_SRP045638 <- create_rse(
    subset(
        human_projects,
        project == "SRP045638" & project_type == "data_sources"
    )
)
```


```{r normalize}
assay(rse_gene_SRP045638, "counts") <- compute_read_counts(rse_gene_SRP045638)
```

Una vez descargados y con los números de lecturas podemos usar expand_sra_attributes(). Sin embargo, tenemos un problema con estos datos.

```{r normalize}
rse_gene_SRP045638$sra.sample_attributes[1:3]
```

Lo hacemos bonito 

```{r normalize}
rse_gene_SRP045638$sra.sample_attributes <- gsub("dev_stage;;Fetal\\|", "", rse_gene_SRP045638$sra.sample_attributes)
rse_gene_SRP045638$sra.sample_attributes[1:3]
```


Ahora sí podemos continuar con el mismo código de ayer.


```{r normalize}
rse_gene_SRP045638 <- expand_sra_attributes(rse_gene_SRP045638)

colData(rse_gene_SRP045638)[
    ,
    grepl("^sra_attribute", colnames(colData(rse_gene_SRP045638)))
]
```

Dado que vamos a usar esta información para un modelo estadístico, será importante que la información esté en el formato correcto de R.

```{r normalize}
## Pasar de character a numeric o factor
rse_gene_SRP045638$sra_attribute.age <- as.numeric(rse_gene_SRP045638$sra_attribute.age)
rse_gene_SRP045638$sra_attribute.disease <- factor(tolower(rse_gene_SRP045638$sra_attribute.disease))
rse_gene_SRP045638$sra_attribute.RIN <- as.numeric(rse_gene_SRP045638$sra_attribute.RIN)
rse_gene_SRP045638$sra_attribute.sex <- factor(rse_gene_SRP045638$sra_attribute.sex)

## Resumen de las variables de interés
summary(as.data.frame(colData(rse_gene_SRP045638)[
    ,
    grepl("^sra_attribute.[age|disease|RIN|sex]", colnames(colData(rse_gene_SRP045638)))
]))
```


```{r normalize}
## Encontraremos diferencias entre muestra prenatales vs postnatales
rse_gene_SRP045638$prenatal <- factor(ifelse(rse_gene_SRP045638$sra_attribute.age < 0, "prenatal", "postnatal"))
table(rse_gene_SRP045638$prenatal)
```

```{r normalize}
## http://rna.recount.bio/docs/quality-check-fields.html
rse_gene_SRP045638$assigned_gene_prop <- rse_gene_SRP045638$recount_qc.gene_fc_count_all.assigned / rse_gene_SRP045638$recount_qc.gene_fc_count_all.total
summary(rse_gene_SRP045638$assigned_gene_prop)
```


```{r normalize}
## 
with(colData(rse_gene_SRP045638), plot(assigned_gene_prop, sra_attribute.RIN))

## Guardemos nuestro objeto entero por si luego cambiamos de opinión
rse_gene_SRP045638_unfiltered <- rse_gene_SRP045638

## Eliminemos las muestras de mala calidad
hist(rse_gene_SRP045638$assigned_gene_prop)
```


```{r normalize}
rse_gene_SRP045638 <- rse_gene_SRP045638[, rse_gene_SRP045638$assigned_gene_prop > 0.3]

## Calculemos los niveles medios de expresión de los genes en nuestras
## muestras.
## Ojo: en un análisis real probablemente haríamos esto con los RPKMs o CPMs
## en vez de las cuentas.
## En realidad usaríamos:
# edgeR::filterByExpr() https://bioconductor.org/packages/edgeR/ https://rdrr.io/bioc/edgeR/man/filterByExpr.html
# genefilter::genefilter() https://bioconductor.org/packages/genefilter/ https://rdrr.io/bioc/genefilter/man/genefilter.html
# jaffelab::expression_cutoff() http://research.libd.org/jaffelab/reference/expression_cutoff.html
#
gene_means <- rowMeans(assay(rse_gene_SRP045638, "counts"))
summary(gene_means)
```
```{r normalize}
## Eliminamos genes
rse_gene_SRP045638 <- rse_gene_SRP045638[gene_means > 0.1, ]

## Dimensiones finales
dim(rse_gene_SRP045638)
```

```{r normalize}
## Porcentaje de genes que retuvimos
round(nrow(rse_gene_SRP045638) / nrow(rse_gene_SRP045638_unfiltered) * 100, 2)
```


## Normalización de datos

* Lean _A hypothetical scenario_ es uno de los artículos sobre `edgeR` <https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25#Sec2> para entender un poco sobre el concepto de _composition bias_.
* Sigue siendo relevante con datos de scRNA-seq como pueden ver en <https://bioconductor.org/books/3.20/OSCA.multisample/multi-sample-comparisons.html#performing-the-de-analysi>. Ahí descubren una serie de pasos para usar métodos desarrollados para bulk RNA-seq y como se pueden usar en scRNA-seq.


```{r normalize}
library("edgeR") # BiocManager::install("edgeR", update = FALSE)
dge <- DGEList(
    counts = assay(rse_gene_SRP045638, "counts"),
    genes = rowData(rse_gene_SRP045638)
)
dge <- calcNormFactors(dge)
```


## Expresión diferencial

Primero que nada, definamos nuestro modelo estadístico. Típicamente, exploraríamos más los datos para revisar que no haya otros problemas con las muestras y para explorar la relación entre nuestras variables.

```{r explore_gene_prop_by_age}
library("ggplot2")
ggplot(as.data.frame(colData(rse_gene_SRP045638)), aes(y = assigned_gene_prop, x = prenatal)) +
    geom_boxplot() +
    theme_bw(base_size = 20) +
    ylab("Assigned Gene Prop") +
    xlab("Age Group")
```

Por ejemplo, usando el paquete de [`variancePartition`](https://bioconductor.org/packages/variancePartition) y [`scater`](https://bioconductor.org/packages/scater) entre otros tal como exploramos en el siguiente video del club de R de LIBD (_[notes in English](https://docs.google.com/document/d/1hil3zwPN6BW6HlwldLbM1FdlLIBWKFNXRUqJJEK_-eY/edit)_).

<iframe width="560" height="315" src="https://www.youtube.com/embed/OdNU5LUOHng" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


Por ahora continuaremos con el siguiente modelo estadístico.

```{r statiscal_model}
mod <- model.matrix(~ prenatal + sra_attribute.RIN + sra_attribute.sex + assigned_gene_prop,
    data = colData(rse_gene_SRP045638)
)
colnames(mod)
```


Ya teniendo el modelo estadístico, podemos usar `limma` para realizar el análisis de expresión diferencial como tal.

```{r run_limma}
library("limma")
vGene <- voom(dge, mod, plot = TRUE)

eb_results <- eBayes(lmFit(vGene))

de_results <- topTable(
    eb_results,
    coef = 2,
    number = nrow(rse_gene_SRP045638),
    sort.by = "none"
)
dim(de_results)
head(de_results)

## Genes diferencialmente expresados entre prenatal y postnatal con FDR < 5%
table(de_results$adj.P.Val < 0.05)

## Visualicemos los resultados estadísticos
plotMA(eb_results, coef = 2)

volcanoplot(eb_results, coef = 2, highlight = 3, names = de_results$gene_name)
de_results[de_results$gene_name %in% c("ZSCAN2", "VASH2", "KIAA0922"), ]
```

* <https://www.genecards.org/cgi-bin/carddisp.pl?gene=ZSCAN2>
* <https://www.genecards.org/cgi-bin/carddisp.pl?gene=VASH2>
* <https://www.genecards.org/cgi-bin/carddisp.pl?gene=KIAA0922>

## Visualizando genes DE


De `vGene$E` podemos extraer los datos normalizados por `limma-voom`. Revisemos los top 50 genes diferencialmente expresados.

```{r pheatmap}
## Extraer valores de los genes de interés
exprs_heatmap <- vGene$E[rank(de_results$adj.P.Val) <= 50, ]

## Creemos una tabla con información de las muestras
## y con nombres de columnas más amigables
df <- as.data.frame(colData(rse_gene_SRP045638)[, c("prenatal", "sra_attribute.RIN", "sra_attribute.sex")])
colnames(df) <- c("AgeGroup", "RIN", "Sex")

## Hagamos un heatmap
library("pheatmap")
pheatmap(
    exprs_heatmap,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = FALSE,
    annotation_col = df
)
```

Los resultados que tenemos no son tan sorprendentes porque hay una diferencia enorme en los perfiles de expresión en el DLPFC entre muestras prenatales y postnatales. Eso lo podemos ver con MDS (multidimensional scaling) tal como describen en [este workflow](http://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html#unsupervised-clustering-of-samples).

```{r plot_mds}
## Para colores
library("RColorBrewer")

## Convirtiendo los grupos de edad a colores
col.group <- df$AgeGroup
levels(col.group) <- brewer.pal(nlevels(col.group), "Set1")
col.group <- as.character(col.group)

## MDS por grupos de edad
plotMDS(vGene$E, labels = df$AgeGroup, col = col.group)

## Convirtiendo los valores de Sex a colores
col.sex <- df$Sex
levels(col.sex) <- brewer.pal(nlevels(col.sex), "Dark2")
col.sex <- as.character(col.sex)

## MDS por sexo
plotMDS(vGene$E, labels = df$Sex, col = col.sex)
```

## Ejercicio

Agreguen los nombres de los genes al `pheatmap`. 

Pistas:

* Revisen la información de `rowRanges(rse_gene_SRP045638)` o `de_results`.
* Exploren que hace la función `match()`.



